#doet voorlopig nog niks

import pickle, pprint
from pysdd.sdd import SddManager, Vtree, WmcManager, SddNode
from randomCNFGenerator import generateRandomCnf
from flatSDDCompiler import SDDcompiler
from thesis_files.propositional_formula import FormulaContainer
import random
import ctypes

class RandomSddApply():
    def __enter__(self):
        print(f" entry dead count = {self.compiler.sddManager.dead_count()}")
        return self #needed to return object to variable after 'as'

    def __exit__(self, exc_type, exc_value, traceback):
        print(f" exit dead count = {self.compiler.sddManager.dead_count()}")
        self.compiler.SddManager.garbage_collect()

    def __init__(self, nrOfVars, nrOfClauses, nrOfCnfs = 1, cnf3 = True, operation = "OR"):
        self.nrOfCnfs = nrOfCnfs
        self.nrOfVars = nrOfVars
        self.nrOfClauses = nrOfClauses
        self.operation = operation
        self.operationInt = 0 if self.operation == "AND" else 1
        self.cnf3 = cnf3
        """
        AND operatie -> zelfde als een sdd met 10 vars en 500 clauses -> skewed result?
        """ 
        self.compiler = SDDcompiler(nrOfVars=nrOfVars)
        self.baseSdds = []
        #self.filename = f"saved/baseSdds_{nrOfSdds}_{nrOfVars}_{nrOfClauses}_{cnf3}_{operation}"
        (self.sddOne, self.sddTwo) = generateRandomSdds()
        #self.saveBaseSdds()

    def collectGarbage(self):
        self.compiler.sddManager.garbage_collect()

    def generateRandomOneSdd(self):
        baseSdds = []
        for i in range(self.nrOfCnfs):
            nextCnf = generateRandomCnf(self.nrOfClauses, self.nrOfVars, self.cnf3)
            (nextSdd, sizeOfDag) = self.compiler.compileToSdd(nextCnf)
            baseSdds.append(nextSdd)
        while len(baseSdds) > 1:
            (firstSdd, secondSdd) = self.getRandomNextSddsToApply(baseSdds)
            baseSdds.remove(firstSdd)
            baseSdds.remove(secondSdd)
            appliedSdd = self.compiler.sddManager.apply(firstSdd, secondSdd, self.operationInt)
            baseSdds.append(appliedSdd)
        return baseSdds[0]

    def generateRandomSdds(self):
        return (generateRandomOneSdd(), generateRandomOneSdd())

    def getMetaDataOne(self, sdd):
        metaData = {}
        metaData["firstSize"] = self.sddOne.size()
        #...

    def getMetaData(self):
        pass
        """if sdds[0].is_true(): #true or false trivial sdd
            print(f"de sdd is triviaal true, er zijn nog {len(sddsCopy)} sdds over")
        if sdds[0].is_false(): #true or false trivial sdd
            print(f"de sdd is triviaal false, er zijn nog {len(sddsCopy)} sdds over")"""

    def saveBaseSdds(self):
        if len(self.baseSdds) == 0:
            generateRandomSdds()
        for i in range(self.nrOfSdds):
            baseSdd = self.baseSdds[i]
            filenameStr = self.filename + str(i)
            filenameBytes = filenameStr.encode('utf-8')
            filenamePointer = ctypes.create_string_buffer(filenameBytes)
            filenamePtrRepresentation = ctypes.cast(filenamePointer, ctypes.c_char_p).value
            baseSdd.save(filenamePtrRepresentation)

    def loadBaseSdds(self):
        baseSdds = []
        for i in range(self.nrOfSdds):
            filenameStr = self.filename + str(i)
            filenameBytes = filenameStr.encode('utf-8')
            filenamePointer = ctypes.create_string_buffer(filenameBytes)
            filenamePtrRepresentation = ctypes.cast(filenamePointer, ctypes.c_char_p).value
            baseSdds.append(self.compiler.sddManager.read_sdd_file(filenamePtrRepresentation))
        return baseSdds
        
        